\documentclass[xcolor=svgnames]{beamer}
\mode<presentation>
{
      \setbeamertemplate{footline}[page number]
      \setbeamercovered{transparent}
      \setbeamertemplate{navigation symbols}{}
      \usecolortheme[named=DarkGreen]{structure}
}

\usepackage[english]{babel}
\usepackage{times}
\usepackage{url}
\usepackage{CJKutf8}
\usepackage{graphics}

\begin{document}
\begin{CJK*}{UTF8}{gbsn}


\title{内存管理}

\begin{frame}
\maketitle
\end{frame}
\begin{frame}{Parkinson's law}
\begin{columns}%[t]
\column{.5\textwidth}
\begin{enumerate}
\item Work expands so as to fill the time available for its completion.
\item[]
\item Data expands to fill the space available for storage.
\end{enumerate}
\column{.5\textwidth}
\includegraphics[width=1.0\textwidth]{parkinson.jpg}
\end{columns}%[t]
\end{frame}

\begin{frame}{程序员希望的内存}
\begin{columns}%[t]
\column{.5\textwidth}
\begin{block}{联系上次作业}
私有的、无穷大、无穷快、便宜、持久性
\end{block}
\column{.5\textwidth}
\includegraphics[width=1.0\textwidth]{memory_hier.jpg}
\end{columns}%[t]
\end{frame}

\begin{frame}{没有内存抽象：程序员直接操作物理内存}
\includegraphics[width=1.0\textwidth]{nomem.png}

a. 内存中一次只能驻留一个程序：\alert{MOV REGISTER1, 1000}

b. 操作系统自身代码难以保护
\end{frame}

\begin{frame}{虚拟内存技术}
虚拟内存技术可以解决以上问题
\begin{itemize}
\item 每个程序有专属地址空间
\item 地址空间分成若干页面
\item 地址空间的页面映射到物理内存的页框内
\item 不是所有的页面都需要放到物理内存中
\item 缺页中断技术
\end{itemize}
\end{frame}

\begin{frame}{虚拟地址、物理地址及内存管理单元}
\includegraphics[width=0.9\textwidth]{mmu.png}
\end{frame}

%\begin{frame}{系统调用的例子}
%\includegraphics[width=0.9\textwidth]{examples.jpg}
%\end{frame}

\begin{frame}{虚拟地址、物理地址及内存管理单元}
\begin{columns}%[t]
\column{.4\textwidth}
\begin{itemize}
\item 虚拟地址空间：64K (16 bit)
\item 物理地址空间：32K (15 bit)
\item 页面大小：4K 
\item 共16个（虚拟）页面，8个（物理）页框
\item 对于大于32K的程序，只能有32K驻留物理内存(右图数字部分)
\end{itemize}
\column{.6\textwidth}
\includegraphics[width=1.0\textwidth]{vm.png}
\end{columns}%[t]
\end{frame}

\begin{frame}{虚拟地址、物理地址及内存管理单元}
\begin{columns}%[t]
\column{.4\textwidth}
\begin{block}{MOV REG, 20500}
20500 = 20K + 20 

页面5 $\rightarrow$ 页框3

12K + 20 = 12308（物理地址）
\end{block}
\begin{block}{MOV REG, 32780}
对应虚拟页面8（缺页）

\alert{what next?}
\end{block}
\column{.6\textwidth}
\includegraphics[width=1.0\textwidth]{vm.png}
\end{columns}%[t]
\end{frame}

\begin{frame}{虚拟地址、物理地址及内存管理单元}
\begin{columns}%[t]
\column{.4\textwidth}
虚拟地址映射到物理地址，考虑右图例子：
\begin{itemize}
\item 页面大小：4K 
\item 页内地址为12位
\item 对于16位机器而言，有4位用于页表索引
\item 因此共有16个虚拟页面
\item 8个物理页框（需3位)
\end{itemize}
\column{.6\textwidth}
\includegraphics[width=1.0\textwidth]{mmu2.png}
\end{columns}%[t]
\end{frame}

%\begin{frame}{对临界资源的互斥访问}
%\includegraphics[width=1.0\textwidth]{mutual.png}
%\end{frame}

%\begin{frame}{信号量机制(Semaphores)}
%为了解决唤醒信号丢失的问题，引入信号量，它是一种特殊的整型变量。在信号量上定义两个\alert{原子操作}：
%\begin{description}
%\item[down]  如果信号量值大于0，则将其减1然后返回；否则，进程在该信号量上进入睡眠
%\item[up]  如果有进程在该信号量上睡眠，则选择其中一个唤醒；否则，信号量加1 
%\end{description}
%\end{frame}
%
%\begin{frame}{用信号量解决生产者--消费者问题}
%\begin{columns}[b]
%\column{.5\textwidth}
%\includegraphics[width=1.0\textwidth]{prodsem.png}
%\column{.5\textwidth}
%\includegraphics[width=1.0\textwidth]{conssem.png}
%\end{columns}%[t]

%该方案中，信号量empty和full具有计数和同步功能，而mutex仅有互斥功能。
%\end{frame}

%\begin{frame}{专门用来实现互斥的特殊信号量 -- 互斥锁}
%互斥锁只有两种状态：locked (1) / unlocked (0)
%
%\includegraphics[width=0.5\textwidth]{mutex.png}
%\end{frame}

%\begin{frame}{互斥锁与忙等待的区别}
%\begin{columns}[b]
%\column{.5\textwidth}
%\includegraphics[width=1.0\textwidth]{mutex.png}
%\column{.5\textwidth}
%\includegraphics[width=1.0\textwidth]{tsl.png}
%\end{columns}%[t]
%后者：不断利用CPU指令测试临界资源，直至时间片用光被从CPU上撤下来
%\end{frame}
%
%\begin{frame}{信号量的危险情形 --- 管程机制的引入}
%\begin{columns}[b]
%\column{.5\textwidth}
%\includegraphics[width=1.0\textwidth]{prodsem.png}
%\column{.5\textwidth}
%\includegraphics[width=1.0\textwidth]{conssem.png}
%\end{columns}%[t]
%\alert{危险:}如果程序员不小心把producer中的down(empty)和down(mutex)顺序颠倒，
%则当缓冲区满时，会发生什么？
%\end{frame}

%\begin{frame}{信号量的危险情形 --- 管程机制的引入}
%\begin{itemize}
%\item 发生死锁。
%\item[]
%\item 因此，最好由编译器自动处理这种容易出错的程序段。---引入管程。
%\item[]
%\item 对比：C++中构造函数与析构函数
%\end{itemize}
%\end{frame}

%\begin{frame}{管程:解决生产者--消费者问题}
%\begin{columns}[b]
%\column{.5\textwidth}
%\includegraphics[width=1.0\textwidth]{mon1.png}
%\column{.5\textwidth}
%\includegraphics[width=1.0\textwidth]{mon2.png}
%\end{columns}%[t]
%
%\alert{注意概念:} 条件变量empty, full以及wait, signal
%
%此外，insert与remove之间的互斥由编译器完成
%\end{frame}

%\begin{frame}{管程:解决生产者--消费者问题}
%\begin{itemize}
%\item 管程内程序段之间的互斥（自动）
%\item 进程同步问题?：条件变量及wait, signal实现
%\begin{itemize}
%\item wait: 将当前进程阻塞，并允许其他进程进入管程
%\item signal: 将被相应条件变量阻塞的进程唤醒
%%\end{itemize}
%\item 上述方法中，signal必须是最后一条指令，为什么？ 
%\end{itemize}
%\end{frame}

%\begin{frame}{消息传递机制：解决不同机器上进程间同步问题}
%\begin{columns}[b]
%\column{.5\textwidth}
%\includegraphics[width=1.0\textwidth]{msgprod.png}
%\column{.5\textwidth}
%\includegraphics[width=1.0\textwidth]{msgcons.png}
%\end{columns}%[t]
%\end{frame}


\end{CJK*}
\end{document}
